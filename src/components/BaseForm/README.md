# BaseForm

The BaseForm component is designed to simplify the creation of forms that:

1. Have validations
2. Can take an arbitrary submit function to call upon submission of validation-passing fields.

Additionally, BaseForm allows for add-ons like multiple field rows (each given its own autogenerated class), a built-in form title, and arbitrary actions available below the form.

A typical BaseForm looks something like this:


```jsx
<BaseForm
  fields={ [
    [ // A field row
      {
        stateKey: 'name'
      }
    ],
    [ // A second field row
      {
        stateKey: 'password',
        type: 'password'
      }
    ]
  ] }
  onSubmit={ attrs => { console.log(attrs); } }
  title="Give us your deets"
/>
```

The above will render a simple form, with no validations, which logs the attributes on click. More complex versions are easily possible. Here's a more complex form, with validations, global errors, and a note from global state:

```jsx
import { BaseForm, utils } from 'rs-components';
const validators = utils.validators; // A group of handy validator functions
...
return (
  <BaseForm
    fields={ [
      [
        {
          stateKey: 'name',
          validator: validators.length(8)
        },
        {
          stateKey: 'email',
          validator: validators.email()
        }
      ],
      [
        {
          stateKey: 'password',
          type: 'password',
          validator: validators.presence()
        },
        {
          stateKey: 'passwordConfirmation',
          type: 'password',
          validator: validators.equalsField('password')
        }
      ],
      [
        {
          stateKey: 'message',
          type: 'textarea',
          startingValue: 'I already have some content!'
        }
      ]
    ] }
    onSubmit={ (attrs) => { dispatch(someAction(attrs)); } }
    submitButton={ <span>Click me</span> }
    title="Gimme info"
    actions={ [
      { label: 'Alert', link: '/or-another-page' }
    ] }
    clearForm={ props.clearFormIf }
    note={ props.somePotentialvalue }
    globalError={ props.potentialError }
  />
);
```

In the above, there are a few interesting things going on:

- Most of the fields have validators. These watch the values, and perform validation on submission. (*If you want to validate as the user types, add `reportErrorImmediately` to any input objects that should do so*). They will block the `onSubmit` function from running until they're all solved.
- There's a field with type `password` and a field with type `textarea`. These both create proper inputs. The default type is `text`.
- Each input can take multiple additional props, including `startingValue`, `label` (automatically produced from `stateKey` by default), `reportErrorImmediately`, and `labelType` (one of 'placeholder', 'label', or 'both').
- The `submitButton` field can take either a string or a component. It defaults to the string "Submit".
- If `clearForm` is set to true (by an incoming prop, for instance), the form will clear.
- If `note` has a value, that value will display between the title and the form.
- If `globalError` has a value, that value will display with a `form__error` class between the title and form. Field-specific errors will take precedence over a passed-in `globalError`.

BaseForm works by rendering [Input](../Input) components, which handle the validation passing and the updating of their parent BaseForm. As a consequence, the Input component doesn't work on its own (at this point), and can't be explored independently.